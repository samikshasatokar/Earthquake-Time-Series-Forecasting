# -*- coding: utf-8 -*-
"""Depth_Prophet.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1tw4e5-1qAbE2T5jxRTBhr1aReJbBkG9i
"""

import magnitude_data_cleaning
from depth_data_cleaning import *
from prophet import Prophet
import datetime
import streamlit as st
from fbprophet.plot import plot_plotly
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error


df_dep = df_dep.reset_index()

df_dep.head()

#!pip install prophet

df_dep = df_dep.rename(columns={'time':'ds', 'depth':'y'})


df_dep['ds'] = [datetime.datetime.date(d) for d in df_dep['ds']]

#df_dep.head()

def dep_prophet():

    m = Prophet()
    m.fit(df_dep)    # We need to provide our whole dataset in the model training part and should not split the same into train and test.

    future = m.make_future_dataframe(periods=100)
    forecast = m.predict(future)

    #forecast
    figure = plot_plotly(m, forecast)
    st.plotly_chart(figure)

    st.markdown('''

                          The graph shown above clearly shows the plots of actual ( data points in black color ) 
                          and predicted ( data line highlighted in blue color). 
            ''')
    metric_df = forecast.set_index('ds')[['yhat']].join(df_dep.set_index('ds').y).reset_index()
    metric_df.dropna(inplace=True)
    mse = round(mean_squared_error(metric_df.y, metric_df.yhat), 2)
    st.write("Mean Squared Error = ", mse)
    st.subheader("Conclusion")
    st.write(
        "The error rate of the model is lesser which shows that the results closer to the observed values.")
    st.markdown(''' 

                Thus, the evaluations clearly represents how Prophet captures the trends in the dataset and 
                forecasts the given future set in few lines of code.
        ''')






